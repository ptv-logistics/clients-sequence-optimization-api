/*
 * Sequence Optimization
 * With the Sequence Optimization service you can find the best route for your transports.
 *
 * The version of the OpenAPI document: 1.8
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ptvgroup.developer.client.sequenceoptimization.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.ptvgroup.developer.client.sequenceoptimization.model.CustomerLocationAttributes;
import com.ptvgroup.developer.client.sequenceoptimization.model.DepotLocationAttributes;
import com.ptvgroup.developer.client.sequenceoptimization.model.LocationType;
import com.ptvgroup.developer.client.sequenceoptimization.model.RoadAccess;
import com.ptvgroup.developer.client.sequenceoptimization.model.TimeInterval;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import com.ptvgroup.developer.client.sequenceoptimization.ApiClient;
/**
 * A specific location where goods have to be picked up or delivered, or where the vehicle is located. A location is either a depot location or a customer location. Depot locations may be found at start or end of **route-stops**.  See [here](./concepts/locations-transports-and-stops) for more information.
 */
@JsonPropertyOrder({
  Location.JSON_PROPERTY_ID,
  Location.JSON_PROPERTY_TYPE,
  Location.JSON_PROPERTY_LATITUDE,
  Location.JSON_PROPERTY_LONGITUDE,
  Location.JSON_PROPERTY_ROAD_ACCESS,
  Location.JSON_PROPERTY_INCLUDE_LAST_METERS,
  Location.JSON_PROPERTY_MATCH_SIDE_OF_STREET,
  Location.JSON_PROPERTY_OPENING_INTERVALS,
  Location.JSON_PROPERTY_CUSTOMER_LOCATION_ATTRIBUTES,
  Location.JSON_PROPERTY_DEPOT_LOCATION_ATTRIBUTES
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-10-27T08:41:48.082993405Z[Etc/UTC]", comments = "Generator version: 7.9.0")
public class Location {
  public static final String JSON_PROPERTY_ID = "id";
  private String id;

  public static final String JSON_PROPERTY_TYPE = "type";
  private LocationType type = LocationType.CUSTOMER;

  public static final String JSON_PROPERTY_LATITUDE = "latitude";
  private Double latitude;

  public static final String JSON_PROPERTY_LONGITUDE = "longitude";
  private Double longitude;

  public static final String JSON_PROPERTY_ROAD_ACCESS = "roadAccess";
  private RoadAccess roadAccess;

  public static final String JSON_PROPERTY_INCLUDE_LAST_METERS = "includeLastMeters";
  private Boolean includeLastMeters = true;

  public static final String JSON_PROPERTY_MATCH_SIDE_OF_STREET = "matchSideOfStreet";
  private Boolean matchSideOfStreet = false;

  public static final String JSON_PROPERTY_OPENING_INTERVALS = "openingIntervals";
  private List<TimeInterval> openingIntervals;

  public static final String JSON_PROPERTY_CUSTOMER_LOCATION_ATTRIBUTES = "customerLocationAttributes";
  private CustomerLocationAttributes customerLocationAttributes;

  public static final String JSON_PROPERTY_DEPOT_LOCATION_ATTRIBUTES = "depotLocationAttributes";
  private DepotLocationAttributes depotLocationAttributes;

  public Location() { 
  }

  public Location id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The unique ID for this location. This ID can be used to reference the location from other elements, for example from transports or the vehicle. The ID does not influence the result.
   * @return id
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getId() {
    return id;
  }


  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setId(String id) {
    this.id = id;
  }


  public Location type(LocationType type) {
    this.type = type;
    return this;
  }

  /**
   * Get type
   * @return type
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TYPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public LocationType getType() {
    return type;
  }


  @JsonProperty(JSON_PROPERTY_TYPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setType(LocationType type) {
    this.type = type;
  }


  public Location latitude(Double latitude) {
    this.latitude = latitude;
    return this;
  }

  /**
   * The latitude value of the location in degrees (WGS84/EPSG:4326) from south to north.
   * minimum: -90
   * maximum: 90
   * @return latitude
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LATITUDE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Double getLatitude() {
    return latitude;
  }


  @JsonProperty(JSON_PROPERTY_LATITUDE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLatitude(Double latitude) {
    this.latitude = latitude;
  }


  public Location longitude(Double longitude) {
    this.longitude = longitude;
    return this;
  }

  /**
   * The longitude value of the location in degrees (WGS84/EPSG:4326) from west to east.
   * minimum: -180
   * maximum: 180
   * @return longitude
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LONGITUDE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Double getLongitude() {
    return longitude;
  }


  @JsonProperty(JSON_PROPERTY_LONGITUDE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLongitude(Double longitude) {
    this.longitude = longitude;
  }


  public Location roadAccess(RoadAccess roadAccess) {
    this.roadAccess = roadAccess;
    return this;
  }

  /**
   * Get roadAccess
   * @return roadAccess
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ROAD_ACCESS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public RoadAccess getRoadAccess() {
    return roadAccess;
  }


  @JsonProperty(JSON_PROPERTY_ROAD_ACCESS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRoadAccess(RoadAccess roadAccess) {
    this.roadAccess = roadAccess;
  }


  public Location includeLastMeters(Boolean includeLastMeters) {
    this.includeLastMeters = includeLastMeters;
    return this;
  }

  /**
   * Include the air-line connection between given and matched coordinates in the relation distance and travel time. Will be ignored when **roadAccess** is specified. We will refer to this type of location to as an _off-road location_.
   * @return includeLastMeters
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_INCLUDE_LAST_METERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Boolean getIncludeLastMeters() {
    return includeLastMeters;
  }


  @JsonProperty(JSON_PROPERTY_INCLUDE_LAST_METERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIncludeLastMeters(Boolean includeLastMeters) {
    this.includeLastMeters = includeLastMeters;
  }


  public Location matchSideOfStreet(Boolean matchSideOfStreet) {
    this.matchSideOfStreet = matchSideOfStreet;
    return this;
  }

  /**
   * Specifies that this waypoint will be reached at the side of street on which it is located. This is useful to prevent the driver from crossing the street to actually reach the location. Is disabled if an OSM profile is used.
   * @return matchSideOfStreet
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_MATCH_SIDE_OF_STREET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Boolean getMatchSideOfStreet() {
    return matchSideOfStreet;
  }


  @JsonProperty(JSON_PROPERTY_MATCH_SIDE_OF_STREET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMatchSideOfStreet(Boolean matchSideOfStreet) {
    this.matchSideOfStreet = matchSideOfStreet;
  }


  public Location openingIntervals(List<TimeInterval> openingIntervals) {
    this.openingIntervals = openingIntervals;
    return this;
  }

  public Location addOpeningIntervalsItem(TimeInterval openingIntervalsItem) {
    if (this.openingIntervals == null) {
      this.openingIntervals = new ArrayList<>();
    }
    this.openingIntervals.add(openingIntervalsItem);
    return this;
  }

  /**
   * The opening intervals at this location. Leaving this parameter empty means that the location is always open. Service (pickup or delivery) can only start within one of the opening intervals. All opening intervals outside of driver availability interval are not considered during the optimization process.
   * @return openingIntervals
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_OPENING_INTERVALS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<TimeInterval> getOpeningIntervals() {
    return openingIntervals;
  }


  @JsonProperty(JSON_PROPERTY_OPENING_INTERVALS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOpeningIntervals(List<TimeInterval> openingIntervals) {
    this.openingIntervals = openingIntervals;
  }


  public Location customerLocationAttributes(CustomerLocationAttributes customerLocationAttributes) {
    this.customerLocationAttributes = customerLocationAttributes;
    return this;
  }

  /**
   * Get customerLocationAttributes
   * @return customerLocationAttributes
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CUSTOMER_LOCATION_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public CustomerLocationAttributes getCustomerLocationAttributes() {
    return customerLocationAttributes;
  }


  @JsonProperty(JSON_PROPERTY_CUSTOMER_LOCATION_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCustomerLocationAttributes(CustomerLocationAttributes customerLocationAttributes) {
    this.customerLocationAttributes = customerLocationAttributes;
  }


  public Location depotLocationAttributes(DepotLocationAttributes depotLocationAttributes) {
    this.depotLocationAttributes = depotLocationAttributes;
    return this;
  }

  /**
   * Get depotLocationAttributes
   * @return depotLocationAttributes
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DEPOT_LOCATION_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public DepotLocationAttributes getDepotLocationAttributes() {
    return depotLocationAttributes;
  }


  @JsonProperty(JSON_PROPERTY_DEPOT_LOCATION_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDepotLocationAttributes(DepotLocationAttributes depotLocationAttributes) {
    this.depotLocationAttributes = depotLocationAttributes;
  }


  /**
   * Return true if this Location object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Location location = (Location) o;
    return Objects.equals(this.id, location.id) &&
        Objects.equals(this.type, location.type) &&
        Objects.equals(this.latitude, location.latitude) &&
        Objects.equals(this.longitude, location.longitude) &&
        Objects.equals(this.roadAccess, location.roadAccess) &&
        Objects.equals(this.includeLastMeters, location.includeLastMeters) &&
        Objects.equals(this.matchSideOfStreet, location.matchSideOfStreet) &&
        Objects.equals(this.openingIntervals, location.openingIntervals) &&
        Objects.equals(this.customerLocationAttributes, location.customerLocationAttributes) &&
        Objects.equals(this.depotLocationAttributes, location.depotLocationAttributes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, type, latitude, longitude, roadAccess, includeLastMeters, matchSideOfStreet, openingIntervals, customerLocationAttributes, depotLocationAttributes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Location {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    latitude: ").append(toIndentedString(latitude)).append("\n");
    sb.append("    longitude: ").append(toIndentedString(longitude)).append("\n");
    sb.append("    roadAccess: ").append(toIndentedString(roadAccess)).append("\n");
    sb.append("    includeLastMeters: ").append(toIndentedString(includeLastMeters)).append("\n");
    sb.append("    matchSideOfStreet: ").append(toIndentedString(matchSideOfStreet)).append("\n");
    sb.append("    openingIntervals: ").append(toIndentedString(openingIntervals)).append("\n");
    sb.append("    customerLocationAttributes: ").append(toIndentedString(customerLocationAttributes)).append("\n");
    sb.append("    depotLocationAttributes: ").append(toIndentedString(depotLocationAttributes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `id` to the URL query string
    if (getId() != null) {
      joiner.add(String.format("%sid%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getId()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `type` to the URL query string
    if (getType() != null) {
      joiner.add(String.format("%stype%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getType()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `latitude` to the URL query string
    if (getLatitude() != null) {
      joiner.add(String.format("%slatitude%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getLatitude()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `longitude` to the URL query string
    if (getLongitude() != null) {
      joiner.add(String.format("%slongitude%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getLongitude()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `roadAccess` to the URL query string
    if (getRoadAccess() != null) {
      joiner.add(getRoadAccess().toUrlQueryString(prefix + "roadAccess" + suffix));
    }

    // add `includeLastMeters` to the URL query string
    if (getIncludeLastMeters() != null) {
      joiner.add(String.format("%sincludeLastMeters%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getIncludeLastMeters()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `matchSideOfStreet` to the URL query string
    if (getMatchSideOfStreet() != null) {
      joiner.add(String.format("%smatchSideOfStreet%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getMatchSideOfStreet()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `openingIntervals` to the URL query string
    if (getOpeningIntervals() != null) {
      for (int i = 0; i < getOpeningIntervals().size(); i++) {
        if (getOpeningIntervals().get(i) != null) {
          joiner.add(getOpeningIntervals().get(i).toUrlQueryString(String.format("%sopeningIntervals%s%s", prefix, suffix,
          "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
    }

    // add `customerLocationAttributes` to the URL query string
    if (getCustomerLocationAttributes() != null) {
      joiner.add(getCustomerLocationAttributes().toUrlQueryString(prefix + "customerLocationAttributes" + suffix));
    }

    // add `depotLocationAttributes` to the URL query string
    if (getDepotLocationAttributes() != null) {
      joiner.add(getDepotLocationAttributes().toUrlQueryString(prefix + "depotLocationAttributes" + suffix));
    }

    return joiner.toString();
  }
}

