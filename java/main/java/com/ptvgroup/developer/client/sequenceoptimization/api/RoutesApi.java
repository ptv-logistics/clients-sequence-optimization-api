/*
 * Sequence Optimization
 * With the Sequence Optimization service you can find the best route for your transports.
 *
 * The version of the OpenAPI document: 1.7
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.ptvgroup.developer.client.sequenceoptimization.api;

import com.ptvgroup.developer.client.sequenceoptimization.ApiClient;
import com.ptvgroup.developer.client.sequenceoptimization.ApiException;
import com.ptvgroup.developer.client.sequenceoptimization.ApiResponse;
import com.ptvgroup.developer.client.sequenceoptimization.Pair;

import com.ptvgroup.developer.client.sequenceoptimization.model.ErrorResponse;
import com.ptvgroup.developer.client.sequenceoptimization.model.OptimizationRequest;
import com.ptvgroup.developer.client.sequenceoptimization.model.OptimizedRouteIdentifier;
import com.ptvgroup.developer.client.sequenceoptimization.model.OptimizedRouteResponse;
import java.util.UUID;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.function.Consumer;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-03-30T09:26:08.496004Z[Etc/UTC]")
public class RoutesApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public RoutesApi() {
    this(new ApiClient());
  }

  public RoutesApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * 
   * Deletes the optimized route whose ID is specified.
   * @param id Unique optimized route ID. (required)
   * @throws ApiException if fails to make API call
   */
  public void deleteOptimizedRoute(UUID id) throws ApiException {
    deleteOptimizedRouteWithHttpInfo(id);
  }

  /**
   * 
   * Deletes the optimized route whose ID is specified.
   * @param id Unique optimized route ID. (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> deleteOptimizedRouteWithHttpInfo(UUID id) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = deleteOptimizedRouteRequestBuilder(id);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("deleteOptimizedRoute", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder deleteOptimizedRouteRequestBuilder(UUID id) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling deleteOptimizedRoute");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/routes/{id}"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Retrieves the status, and if the status is SUCCEEDED, the optimized route whose ID is specified.
   * @param id Unique optimized route ID. (required)
   * @return OptimizedRouteResponse
   * @throws ApiException if fails to make API call
   */
  public OptimizedRouteResponse getOptimizedRoute(UUID id) throws ApiException {
    ApiResponse<OptimizedRouteResponse> localVarResponse = getOptimizedRouteWithHttpInfo(id);
    return localVarResponse.getData();
  }

  /**
   * 
   * Retrieves the status, and if the status is SUCCEEDED, the optimized route whose ID is specified.
   * @param id Unique optimized route ID. (required)
   * @return ApiResponse&lt;OptimizedRouteResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<OptimizedRouteResponse> getOptimizedRouteWithHttpInfo(UUID id) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getOptimizedRouteRequestBuilder(id);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getOptimizedRoute", localVarResponse);
        }
        return new ApiResponse<OptimizedRouteResponse>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<OptimizedRouteResponse>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getOptimizedRouteRequestBuilder(UUID id) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getOptimizedRoute");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/routes/{id}"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Performs desired sequence optimization. The call is asynchronous and only one optimization can be started at a time. Returns unique optimized route ID upon success. Use the unique ID returned to subsequently track the progress of the optimization and to get the optimized route. The number of transports in the request is used to calculate the number of transactions, see [here](../../help/faq-help) for more information.
   * @param optimizationRequest Specific instance for sequence optimization. (required)
   * @param considerTransportPriorities Set transport priority consideration to true or false.  See [here](./concepts/transport-priorities) for more information. (optional, default to false)
   * @return OptimizedRouteIdentifier
   * @throws ApiException if fails to make API call
   */
  public OptimizedRouteIdentifier startAndCreateOptimizedRoute(OptimizationRequest optimizationRequest, Boolean considerTransportPriorities) throws ApiException {
    ApiResponse<OptimizedRouteIdentifier> localVarResponse = startAndCreateOptimizedRouteWithHttpInfo(optimizationRequest, considerTransportPriorities);
    return localVarResponse.getData();
  }

  /**
   * 
   * Performs desired sequence optimization. The call is asynchronous and only one optimization can be started at a time. Returns unique optimized route ID upon success. Use the unique ID returned to subsequently track the progress of the optimization and to get the optimized route. The number of transports in the request is used to calculate the number of transactions, see [here](../../help/faq-help) for more information.
   * @param optimizationRequest Specific instance for sequence optimization. (required)
   * @param considerTransportPriorities Set transport priority consideration to true or false.  See [here](./concepts/transport-priorities) for more information. (optional, default to false)
   * @return ApiResponse&lt;OptimizedRouteIdentifier&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<OptimizedRouteIdentifier> startAndCreateOptimizedRouteWithHttpInfo(OptimizationRequest optimizationRequest, Boolean considerTransportPriorities) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = startAndCreateOptimizedRouteRequestBuilder(optimizationRequest, considerTransportPriorities);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("startAndCreateOptimizedRoute", localVarResponse);
        }
        return new ApiResponse<OptimizedRouteIdentifier>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<OptimizedRouteIdentifier>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder startAndCreateOptimizedRouteRequestBuilder(OptimizationRequest optimizationRequest, Boolean considerTransportPriorities) throws ApiException {
    // verify the required parameter 'optimizationRequest' is set
    if (optimizationRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'optimizationRequest' when calling startAndCreateOptimizedRoute");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/routes";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("considerTransportPriorities", considerTransportPriorities));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(optimizationRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
